1.
    Обобщения очень важны, поскольку позволяют создавать код, который:
    + a) обеспечивает безопасность типов;
    + б) пригоден для повторного использования;
    + в) отличается высокой надежностью;

2.
    В качестве аргумента типа нельзя указывать простой тип, это длжен быть тип класса.
        (Integer но не int)

3.
    Объявление класса FlightSched с двумя параметрами типа:
        class FlightSched<T, V> {}

4.
    Второй параметр V: класс Thread или его производный (подкласс):
        class FlightSched<T, V extends Thread> {}

5.
    Второй параметр V: == классу T или его подклассу:
        class FlightSched<T, V extends T> {}

6.
    Знак ? в обобщениях обозначает неизвестный тип данных,
    т.е. в метод с ? знаком можно передавать любой тип объекта (Double, Integer, String и др.)
    указанного класса.

7.
    Шаблон аргумента может быть ограниченным:
        Здесь шаблон ? устанавливает соответсвие
        классу A или его подклассам:
        static void test(Gen<? extends A> ob) { ... }

8.
    Обобщенный метод который определяет тип передаваемого ему параметра,
    и возвращающий объект, тип которого соответствует параметру типа,
    можно объявить сл. образом:
        public Gen<T> myGen(Gen<T> obj)
        {
            // ...

            return obj;
        }

9.
    Пример реализации обобщенного интерфейса:
        interface IGenIF<T, V extends T> { // ... }

    // Интерфейс
    interface IGenIF<T, V extends T>
    {
        // ...
        void sayHello();
    }

    // Реализация интерфейса:
    class MyClass<T, V extends T> implements IGenIF<T, V>
    {

        public void sayHello()
        {
            System.out.println("Hello =)");
        }
    }

    // Создание объекта класса MyClass
    MyClass<Object, Integer> mc = new MyClass<>();
    mc.sayHello();

10.
    Создание объекта базового типа, обобщенного класса Counter<T>:
        Counter cObj = new Counter;

11.
    Параметры типа не существуют на стадии выполнения программы.
    При компиляции кода, все сведения об обобщенных типах удаляются.

12.
    Stack.java

13:
    Пара угловых скобок: <> обозначает пустой список аргументов типа.

14:
    Строку кода:
        MyClass<Double, String> obj = new MyClass<Double, String>(1.1, "Привет");
    Можно упростить до следующего вида:
        MyClass<Double, String> obj = new MyClass<>(1.1, "Привет");
    Здесь компилятор сам определит (выведет) типы аргументов требующиеся конструктору,
    исходя из контекста.
    ++ (Существенно сокращает размер неоправданно громоздких объявлений)